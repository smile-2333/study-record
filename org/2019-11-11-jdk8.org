#+TITLE:  jdk
#+STARTUP: indent
* jdk8
** Lambda表达式
基本结构：
(param1,param2,param3)->{}

关于函数式接口：
1. 如果一个接口有一个抽象方法，那么该就接口就是一个函数式接口
2. 如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口
3. 如果某个接口只有一个抽象方法，但我们并没有声明FunctionalInterface注解，那么编译器依旧会将该接口看作是函数式接口

Lambda表达式为Java添加了缺失的函数式编程特性，使我们能将函数当作一等公民对待
在将函数作为一等公民语言中，Lambda表达式的类型是函数。但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象类型-函数式接口(functional interface)
*** Function interface
- Consumer
- Function----apply----compose----andThen
- BiFunction----apply----andThen
- Predicate----test----and----or
- Runnable
- Supplier
不接收参数，返回结果

Java编译器对同lambda产生的不同Functional接口，调用instanceof被认为是true
#+BEGIN_SRC java
Consume<Integer>consume = ele->System.out.println(ele)
IntConsume intConsume = ele->System.out.println(ele)

System.out.println(intConsume instanceof consume)  //true
System.out.println(consume instanceof intConsume)  //true
#+END_SRC
*** 作用
传递行为，而不仅仅是值
- 提高抽象层次
- API重用性更好
- 更加灵活
** Optional
不要作为方法参数/成员变量，应作为返回值
** 方法引用(语法糖)
当某个方法与该Function签名一致时，编译器在编译时，会将该方法引用作为其实现的方法体的执行内容，并将参数传递给该方法引用对应的方法
四类
1. 类名::静态方法名
2. 引用名(对象名)::实例方法名
3. 类名::实例方法名(String::toUpperCase)
   原理：所有的实例方法名，本身在被编译后都存在this,即对当前对象的引用也是参数
4. 构造方法引用：类名::new
** Stream
- collection提供了新的Stream()方法
- 流不存储值，通过管道的方式获取值
- 本质是函数式的，对流的操作会生成一个结果，不过并不会修改底层的数据源，集合可以作为流的底层数据源
- 延迟查找，很多流操作(过滤、映射、排序等)都可以延迟实现
- 具化原生类型的如IntSteam等，可以避免性能损耗，和使用其中封装的对应类型的操作函数，如min(),sum()
- 由于流是惰性的，所以对于最终终止操作可能产生的值的为null的情况下，对应的函数都会返回Optional或Option类似的具化类
- 和迭代器不同的是，Steam可以并行化操作，迭代器只能命令式地、串行化操作
- Collection关注的是数据与数据存储本身
- Stream关注的是对数据的计算，Stream无法重复消费
- combiner只有在并行情况下，CONCURRENT不启用的情况下(会产生多个结果容器)，才会调用该方法返回函数进行合并
1. source
2. zero or more operation
3. termination operation
流操作的分类
1. 惰性求值
2. 及早求值
*** Stream
**** collect
#+BEGIN_SRC java
  //equivalent, 第三个参数是由于Stream支持并行操作，因此，多个线程并行时，会存在多个中间存储列表,可以认为是accumulator产生的结果集，最后使用combiner将多个并行的结果集合并
  <R> R collect(Supplier<R> supplier,
                    BiConsumer<R, ? super T> accumulator,
                    BiConsumer<R, R> combiner);
  Stream<String> stream = Stream.of("hello", "world", "hello world");
  stream.collect(()->new LinkedList<>(),(theList,ele)->theList.add(ele),(theList1,theList2)->theList1.addAll(theList2));
  stream.collect(LinkedList::new, LinkedList::add,LinkedList::addAll);
#+END_SRC
**** flatMap

**** iterate和limit
配置seed和function生成无限制的Stream，在用limit限制
*** IntStream
- range()
- rangeClosed()
- summaryStatistics()数值操作
*** Collectors
JDK提供的工具类
- toCollection 指定生成的集合类型
- joining 连接

*** 仿SQL的命令操作
**** 分组
#+BEGIN_SRC java
Student student1 = new Student("zhangsan",100,20);
Student student2 = new Student("lisi",90,20);
Student student3 = new Student("wangwu",90,30);
Student student4 = new Student("zhangsan",80,40);

List<Student>students = Arrays.asLisy(student1,student2,student3,student4);
Map<String,List<String>> map = students.stream().collect(collectors.groupingBy(Student::getName));
Map<String,List<String>> map = students.stream().collect(collectors.groupingBy(Student::getName,Collectors.counting()));
Map<String,List<String>> map = students.stream().collect(collectors.groupingBy(Student::getName,Collectors.averagingDouble(Student::getScore)));
#+END_SRC
**** 分区
#+BEGIN_SRC java
Map<Boolean,List<Student>>map = students.stream.collect(Collectors.partitionBy(student->student.getScore>=90));
#+END_SRC
*** Collector
- 是一个接口，它是一个可变的汇聚操作，将输入元素累积到一个可变的结果容器中；它在所有元素都处理完毕后，将累积的结果转换为转换为一个最终的表示(这是一个可选操作)；它支持串行和并行两种方式执行
- Collectos本身提供了关于Collector的常见汇聚实现，Collectors本身实际是一个工厂
- supplier()、accmulator()、combiner()、finisher()
- 为了确保串行与并行操作结果的等价性，Collector函数需要满足两个条件：identity与associativity--->(a==combiner.apply(a,supplier.get())
*** 多级分组
*** 增强的接口
**** Comparator
**** 类型推断
#+BEGIN_SRC java
//<? super T>针对对象的父级接口考量
//可以根据A,B,C来进行特性的比较
class Student implements A,B,C{
}

List<String> list = Arrays.asList("nihao","hello","world","welcome");
list.sort((item1,item2)->item1.length-item2.length); //正序
list.sort((item1,item2)->item1.length-item2.length); //逆序

//辅助类+方法引用
list.sort(Comparator.comparingInt(String::length));
list.sort(Comparator.comparingInt(String::length).reverse);

list.sort(Comparator.comparingInt(item->item.length).reverse); //compile error，未有明确原因，极大可能是编译器bug

list.sort(Comparator.comparingInt(String::length).thenComparing((item1,item2)->item1.length()-item2.length()));
#+END_SRC
*** Characteristics
收集器的trigger，用于开启特性
- CONCURRENT 结果容器可被并发重用，导致combiner是否被执行(多个线程共用一个结果容器,combiner的返回函数不会被执行)
- UNORDERED 无序
- IDENTITY_FINISH 收集结果与最终结果一致，开启则不受检，直接类型转换(提高效率)
*** Collector
*** BaseStream
*** Spliterator(可被认为是enhence的iterator)
- 八个特性值
- trySplit
- tryAdvance
*** ReferencePipeline
hold on 数据源和中间操作的引用(不会立刻执行)
*** Sink
Consumer的增强
** 时间处理
*** LocalDate
- now()
- of(2017,2,4)

*** MonthDay
*** LocalTime
- now()
- plusHours(int)
- plusMinutes(int)
*** Clock
*** ZoneId
- getAvailableZoneIds()
- of(String)
*** LocalDateTime
*** ZoneDateTime
- of()
*** YearMonth
*** Period
- Period.between
*** Instant
- now()
