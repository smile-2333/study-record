#+TITLE:  java collection
#+STARTUP: indent
分析版本openjdk11.0.6
* LinkedList
** 查找
检查index边界，>0 <size
从first开始迭代，直接迭代次数满足index
** 遍历
用first开始迭代
** 插入
是结尾->插入尾部
插入中间
** 删除
获取前驱，后继，前驱指向后继
* ArrayList
** modCount
modCount如字面意思，是修改次数，因为该容器是线程不安全的，所以modCount可以在remove或者其他情况下，检车modCount是否与迭代器Itr开始时，不一致，则说明，有其他的在动，直接抛ConcurrentModificationException
** 扩容机制为一般
** 插入
*** append
modCount++
确保是否需要扩容，是就扩容，然后复制，最后在加元素
*** 指定位置插入，其他部分往后挪
** 删除
** 遍历
* HashMap
** hash处理
拿到hashcode后，经过移位和异或运算，生成hash值
** 插入
** 扩容机制
1. 在最开始空的时候调用默认值1<<4进行空间开辟
2. 之后，当到达阈值时，每次扩容为最小的2的n次幂，大于元素总数，然后进行重排
** 序列化
** trick
1. 1.7及之前是经典的哈希表实现，1.8开始改为桶+链表/红黑树
2. 1.7 hash实现不良
3. 桶大小必须为2^n原因为，作取模时，使用了位运算
4. 1.8 hash实现为取得hashCode之后，将高位部分和低位部分进行异或
* LinkedHashMap
* TreeMap