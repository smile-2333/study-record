#+TITLE: 操作系统
#+STARTUP: indent
* 内核分类
** hrbrid
*** Darwin-XNU
** 宏内核
Linux
** 微内核
*** NT
* 内存管理演化
单道程序 --> 直接访问

多道程序 --> 多程序并发，为了让程序不直接访问到物理内存或者说彼此造成冲突，需要做一层隔离
** 分页模型
虚拟地址的总额对应物理地址的总额，在程序链接时产生

1. 以一对一的地址映射来做，假设以虚拟地址作为物理地址索引来找具体的物理地址，即物理内存作为一个超大数组，里面每个元素存放了一个对应的物理地址，虚拟地址换成物理地址就是以虚拟地址对应的下标来做映射
不可行，因为内存已经完全被作为地址转换关系表用完了，因为粒度太小
2. 如果让关联表尽可能小点呢，分块，让映射都是基于一块一块，那么只要虚拟地址和物理地址的块大小一样，关联的地址，一个就可以对应一坨映射关系(分页模型)

[[file:~/study-record/img/mmu.png][mmu]] 图示
*** MMU页表
存在与内存中，
一个顶级页目录，多个中级页目录，最后才是页表
而虚拟地址按照规范，每一块的信息作为对应的查询位置
[[file:~/study-record/img/mmu_page_table.png][mmu页表]]
**** TODO 原因
* Cache
1. 缓解CPU与内存由于制造工艺导致量级差距
2. 本质是对于程序运行规律的一种假设，即程序的局部性原理
** level
*** 1级缓存
   核心专属，分为 指令Cache 和 数据Cache
*** 2级缓存
核心专属
*** 3级缓存
全核心共享
** protocol
*** MESI 协议
[[file:~/study-record/img/os_cache_modify.png][(M)odify]]
[[file:~/study-record/img/os_cache_exclusive.png][(E)xclusive]]
[[file:~/study-record/img/os_cache_share.png][(S)hare]]
(I)nvalid
* 同步原语
** 原子变量
** 关中断
防止断码块中途被打断，单核CPU可以这么搞
*** v1 非嵌套代码
直接开关中断即可
*** v2 压栈确认是否开启
即到最外一层才可以成功开启中断，防止内外层开启导致的信息不一致
** 自旋锁
由硬件提供了最基本的原子指令，用于确保读取锁变量的过程中是原子性的


如果一个CPU获取自旋锁后发生中断，中断代码里也尝试获取自旋锁，那么自旋锁永远不会被释放，发生死锁。
[[file:~/study-record/img/spinlock_flow.png][spin lock flow]]
** 信号量
