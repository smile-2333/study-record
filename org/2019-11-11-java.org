#+TITLE:  java
#+STARTUP: indent
* basic
** array
*** consruct
**** 动态初始化(指定长度)
***** 默认值
int->0
float/double->0.0
char->'\u0000'
boolean->false
***** usage
#+BEGIN_SRC java
int [] arrays = new int[100];
#+END_SRC
**** 静态初始化(指定内容)
#+BEGIN_SRC java
int [] arrays = {1,3,4,5,2,9}
#+END_SRC
** memory
*** stack
方法的局部变量(参数和定义的变量)
*** heap
*** method area
1.8其实现为PermGen(永久代)，1.8以后变成Metaspace(元空间x)
*** Native Method Stack
本地方法栈，与操作系统相关
*** pc register
与CPU相关
** 字符串
*** 常量池
*** trick
推荐字面量和变量进行比较
#+BEGIN_SRC java
"aa".equal(a)

#+END_SRC
*** frequent method
**** String concat(String str)
**** char charAt(int index)
**** int indexOf(String str)
str在本字符串首次出现的位置，没有则返回-1
**** String subtring
***** (int begin)
***** (int begin, int end)
**** 转换
***** char [] toCharArray()
***** byte [] getBytes()
***** String replace(CharSequence oldString, CharSequence newString)
***** String[]split(String regex)
** 工具类
*** Arrays
**** static String toString(int[]/float[]/...)
打印出数组，格式默认为[1,2,3...]
** annotation
*** custom
*** meta-annotation
**** @Target
**** @Retention
**** @Inherited
**** @Documented
**** @Repeatable
*** basic
**** @Override
**** @Deprecated
**** @SuppressWarnings
**** @SafeVarargs
**** @FunctionInterface
** regex
*** pattern
#+BEGIN_SRC java
// 单纯的匹配是否存在
String str = "(a)";
String pattern = "[(a)]{3}";
boolean matches = Pattern.matches(pattern, str);
System.out.println(matches);

String str = "(a)";
String pattern = "\\(a\\)";
// []内部的符号自动被转义，相当于原本需要\\(现在不需要\\
String pattern2 = "[(a)]{3}";
Pattern compile = Pattern.compile(pattern);
Matcher matcher = compile.matcher(str);
if (matcher.find()){
    System.out.println(matcher.group(0));
}
#+END_SRC
* jdk8
** Lambda表达式
基本结构：
(param1,param2,param3)->{}

关于函数式接口：
1. 如果一个接口有一个抽象方法，那么该就接口就是一个函数式接口
2. 如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口
3. 如果某个接口只有一个抽象方法，但我们并没有声明FunctionalInterface注解，那么编译器依旧会将该接口看作是函数式接口

Lambda表达式为Java添加了缺失的函数式编程特性，使我们能将函数当作一等公民对待
在将函数作为一等公民语言中，Lambda表达式的类型是函数。但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象类型-函数式接口(functional interface)
*** Function interface
- Consumer
- Function----apply----compose----andThen
- BiFunction----apply----andThen
- Predicate----test----and----or
- Runnable
- Supplier
不接收参数，返回结果

Java编译器对同lambda产生的不同Functional接口，调用instanceof被认为是true
#+BEGIN_SRC java
Consume<Integer>consume = ele->System.out.println(ele)
IntConsume intConsume = ele->System.out.println(ele)

System.out.println(intConsume instanceof consume)  //true
System.out.println(consume instanceof intConsume)  //true
#+END_SRC
*** 作用
传递行为，而不仅仅是值
- 提高抽象层次
- API重用性更好
- 更加灵活
** Optional
不要作为方法参数/成员变量，应作为返回值
** 方法引用(语法糖)
当某个方法与该Function签名一致时，编译器在编译时，会将该方法引用作为其实现的方法体的执行内容，并将参数传递给该方法引用对应的方法
四类
1. 类名::静态方法名
2. 引用名(对象名)::实例方法名
3. 类名::实例方法名(String::toUpperCase)
   原理：所有的实例方法名，本身在被编译后都存在this,即对当前对象的引用也是参数
4. 构造方法引用：类名::new
** Stream
- collection提供了新的Stream()方法
- 流不存储值，通过管道的方式获取值
- 本质是函数式的，对流的操作会生成一个结果，不过并不会修改底层的数据源，集合可以作为流的底层数据源
- 延迟查找，很多流操作(过滤、映射、排序等)都可以延迟实现
- 具化原生类型的如IntSteam等，可以避免性能损耗，和使用其中封装的对应类型的操作函数，如min(),sum()
- 由于流是惰性的，所以对于最终终止操作可能产生的值的为null的情况下，对应的函数都会返回Optional或Option类似的具化类
- 和迭代器不同的是，Steam可以并行化操作，迭代器只能命令式地、串行化操作
- Collection关注的是数据与数据存储本身
- Stream关注的是对数据的计算，Stream无法重复消费
- combiner只有在并行情况下，CONCURRENT不启用的情况下(会产生多个结果容器)，才会调用该方法返回函数进行合并
1. source
2. zero or more operation
3. termination operation
流操作的分类
1. 惰性求值
2. 及早求值
*** Stream
**** collect
#+BEGIN_SRC java
  //equivalent, 第三个参数是由于Stream支持并行操作，因此，多个线程并行时，会存在多个中间存储列表,可以认为是accumulator产生的结果集，最后使用combiner将多个并行的结果集合并
  <R> R collect(Supplier<R> supplier,
                    BiConsumer<R, ? super T> accumulator,
                    BiConsumer<R, R> combiner);
  Stream<String> stream = Stream.of("hello", "world", "hello world");
  stream.collect(()->new LinkedList<>(),(theList,ele)->theList.add(ele),(theList1,theList2)->theList1.addAll(theList2));
  stream.collect(LinkedList::new, LinkedList::add,LinkedList::addAll);
#+END_SRC
**** flatMap

**** iterate和limit
配置seed和function生成无限制的Stream，在用limit限制
*** IntStream
- range()
- rangeClosed()
- summaryStatistics()数值操作
*** Collectors
JDK提供的工具类
- toCollection 指定生成的集合类型
- joining 连接

*** 仿SQL的命令操作
**** 分组
#+BEGIN_SRC java
Student student1 = new Student("zhangsan",100,20);
Student student2 = new Student("lisi",90,20);
Student student3 = new Student("wangwu",90,30);
Student student4 = new Student("zhangsan",80,40);

List<Student>students = Arrays.asLisy(student1,student2,student3,student4);
Map<String,List<String>> map = students.stream().collect(collectors.groupingBy(Student::getName));
Map<String,List<String>> map = students.stream().collect(collectors.groupingBy(Student::getName,Collectors.counting()));
Map<String,List<String>> map = students.stream().collect(collectors.groupingBy(Student::getName,Collectors.averagingDouble(Student::getScore)));
#+END_SRC
**** 分区
#+BEGIN_SRC java
Map<Boolean,List<Student>>map = students.stream.collect(Collectors.partitionBy(student->student.getScore>=90));
#+END_SRC
*** Collector
- 是一个接口，它是一个可变的汇聚操作，将输入元素累积到一个可变的结果容器中；它在所有元素都处理完毕后，将累积的结果转换为转换为一个最终的表示(这是一个可选操作)；它支持串行和并行两种方式执行
- Collectos本身提供了关于Collector的常见汇聚实现，Collectors本身实际是一个工厂
- supplier()、accmulator()、combiner()、finisher()
- 为了确保串行与并行操作结果的等价性，Collector函数需要满足两个条件：identity与associativity--->(a==combiner.apply(a,supplier.get())
*** 多级分组
*** 增强的接口
**** Comparator
**** 类型推断
#+BEGIN_SRC java
//<? super T>针对对象的父级接口考量
//可以根据A,B,C来进行特性的比较
class Student implements A,B,C{
}

List<String> list = Arrays.asList("nihao","hello","world","welcome");
list.sort((item1,item2)->item1.length-item2.length); //正序
list.sort((item1,item2)->item1.length-item2.length); //逆序

//辅助类+方法引用
list.sort(Comparator.comparingInt(String::length));
list.sort(Comparator.comparingInt(String::length).reverse);

list.sort(Comparator.comparingInt(item->item.length).reverse); //compile error，未有明确原因，极大可能是编译器bug

list.sort(Comparator.comparingInt(String::length).thenComparing((item1,item2)->item1.length()-item2.length()));
#+END_SRC
*** Characteristics
收集器的trigger，用于开启特性
- CONCURRENT 结果容器可被并发重用，导致combiner是否被执行(多个线程共用一个结果容器,combiner的返回函数不会被执行)
- UNORDERED 无序
- IDENTITY_FINISH 收集结果与最终结果一致，开启则不受检，直接类型转换(提高效率)
*** Collector
*** BaseStream
*** Spliterator(可被认为是enhence的iterator)
- 八个特性值
- trySplit
- tryAdvance
*** ReferencePipeline
hold on 数据源和中间操作的引用(不会立刻执行)
*** Sink
Consumer的增强
** 时间处理
*** LocalDate
- now()
- of(2017,2,4)

*** MonthDay
*** LocalTime
- now()
- plusHours(int)
- plusMinutes(int)
*** Clock
*** ZoneId
- getAvailableZoneIds()
- of(String)
*** LocalDateTime
*** ZoneDateTime
- of()
*** YearMonth
*** Period
- Period.between
*** Instant
- now()
* jdk9
** 允许接口有默认方法
#+BEGIN_SRC java
public interface test{
  default void print1(){
    print();
  }

  default void print1(){
    print();
  }

  private void print(){
    System.out.println(111)
  }
}
#+END_SRC
** 集合增加了of
* 生态组件
** lombok
*** @Data
@Data 注解会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。
*** @AllArgsConstructor/@NoArgsConstructor
分别提供全参构造方法和无参构造方法
*** @Builder
#+BEGIN_SRC java
@Builder
public class Hero {
    private int id;
    private String name;
}

public class Main{
  public void static main(String[]args){
    Hero hero = Hero.builder().id(1).name("haha").build();
  }
}
#+END_SRC
** spring
*** mail
**** build script
***** gradle
    implementation 'org.springframework.boot:spring-boot-starter-mail'
***** usage 
****** MailSender and SimpleMailMessage Usage
ref https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mail.html
#+BEGIN_SRC java
public class SimpleOrderManager implements OrderManager {

    private MailSender mailSender;
    private SimpleMailMessage templateMessage;

    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void setTemplateMessage(SimpleMailMessage templateMessage) {
        this.templateMessage = templateMessage;
    }

    public void placeOrder(Order order) {

        // Do the business calculations...

        // Call the collaborators to persist the order...

        // Create a thread safe "copy" of the template message and customize it
        SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage);
        msg.setTo(order.getCustomer().getEmailAddress());
        msg.setText(
            "Dear " + order.getCustomer().getFirstName()
                + order.getCustomer().getLastName()
                + ", thank you for placing order. Your order number is "
                + order.getOrderNumber());
        try{
            this.mailSender.send(msg);
        }
        catch(MailException ex) {
            // simply log it and go on...
            System.err.println(ex.getMessage());
        }
    }
}
#+END_SRC
****** QQ mail config
#+BEGIN_SRC java
@Configuration
public class MailConfig {
    @Bean
    public JavaMailSender getJavaMailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost("smtp.qq.com");
        mailSender.setPort(587);

        mailSender.setUsername("980959100@qq.com");
        mailSender.setPassword("affiapghpreobebb");

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.debug", "true");

        return mailSender;
    }
}
#+END_SRC
** json
*** jackson
